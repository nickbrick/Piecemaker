@implements IDisposable
@inject IJSRuntime JsRuntime
@using ChessDotCore;
@using Piecemaker.Blazor.Shared;
<h3>Table @Table.Id.ToString("x"): @Table.Status</h3>
<div id="myBoard" style="width: 400px"></div>
<CascadingValue Value="@this">
    <TableActionButton Action="TableActionButton.TableAction.FindNew"></TableActionButton>
    <TableActionButton Action="TableActionButton.TableAction.OpenClose"></TableActionButton>
    <TableActionButton Action="TableActionButton.TableAction.SwapSides"></TableActionButton>
</CascadingValue>
<audio id="audio-check" style="display:none;" src="/webm/move-check.webm"></audio>
<audio id="audio-capture" style="display:none;" src="/webm/capture.webm"></audio>
<audio id="audio-promote" style="display:none;" src="/webm/promote.webm"></audio>
<audio id="audio-move-opponent" style="display:none;" src="/webm/move-opponent.webm"></audio>
<audio id="audio-move-self" style="display:none;" src="/webm/move-self.webm"></audio>
<ul>
    @foreach (var line in DebugState)
    {
        <li>@line</li>
    }
</ul>
<p>Piecemaker alpha @System.Environment.GetEnvironmentVariable("HEROKU_RELEASE_VERSION")</p>
@code {
    public Engine.Program PiecemakerGame => Blazor.Program.Piecemaker;
    public Client Client { get; set; }
    [Parameter] public Table Table { get; set; }
    private string[] DebugState => GetDebugStateString();
    private string SimpleFen => Table.Game.GetFen().Split()[0];
    private string LastMove => Table.Game.Moves.LastOrDefault()?.ToString() ?? "";
    private Player Winner => Table.Game.IsCheckmated(Player.White) ? Player.Black : Table.Game.IsCheckmated(Player.Black) ? Player.White : Player.None;
    [Inject]
    public IJSRuntime JSRuntime { get; set; }
    public GameComponent()
    {
    }
    protected override void OnInitialized()
    {
        Table.ValidMoveWasMade += Table_ValidMoveWasMade;
        Table.ClientJoined += Table_ClientJoined;
        Table.ClientDisconnected += Table_ClientDisconnected;
        Table.SideSwapActionHandled += Table_SideSwapClicked;
        Table.StatusChanged += Table_StatusChanged;
        Client = Table.Join();
    }
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("init", Table.Game.GetFen(), Client.Player.ToString().ToLower(), LastMove);
            await InitGameComponentInstance();
        }
        await JSRuntime.InvokeVoidAsync("setValidMoves",
            Client.ValidMoves,
            Table.Game.WhoseTurn.ToString().ToLower(),
            Table.Game.WhiteSummonablePieces.Select(s => "w" + s).ToList().Concat(
            Table.Game.BlackSummonablePieces.Select(s => "b" + s.ToUpper()).ToList())
        );
        await JSRuntime.InvokeVoidAsync("updateMana", GetGameManasAndCosts());

    }
    private async Task InitGameComponentInstance()
    {
        var dotNetObjRef = DotNetObjectReference.Create(this);
        await JSRuntime.InvokeVoidAsync("registerGameComponentObject", dotNetObjRef);
    }
    [JSInvokable("MakeMove")]
    public async Task<bool> MakeMove(string move)
    {
        var result = Client.MakeMove(move);
        if (!result)
        {
            await JSRuntime.InvokeVoidAsync("setPosition", SimpleFen);
        }
        await InvokeAsync(StateHasChanged);
        return result;
    }
    private async void Table_ValidMoveWasMade(object sender, MoveEventArgs e)
    {
        try
        {
            System.Diagnostics.Debug.WriteLine(e.NewPositionSimpleFen);
            await JSRuntime.InvokeVoidAsync("setPosition", e.NewPositionSimpleFen);
            await JSRuntime.InvokeVoidAsync("highlightSquares", e.From, e.To);
            await JSRuntime.InvokeVoidAsync("playSound", GetSoundName(e));

            System.Diagnostics.Debug.WriteLine("Table_MoveWasMade");
            await InvokeAsync(StateHasChanged);
        }
        catch (TaskCanceledException ex) { }
    }
    private string GetSoundName(MoveEventArgs e)
    {
        if (e.Type.HasFlag(MoveType.Check)) return "#audio-check";
        if (e.Type.HasFlag(MoveType.Capture)) return "#audio-capture";
        if (e.Type.HasFlag(MoveType.Summon)) return "#audio-promote";
        if (e.Player != Client.Player) return "#audio-move-opponent";
        return "#audio-move-self";
    }
    private Dictionary<string, int> GetGameManasAndCosts()
    {
        return new Dictionary<string, int>
    {
            {".piece-cost-wP", Table.Game.WhitePieceCosts.Pawn},
            {".piece-cost-wN", Table.Game.WhitePieceCosts.Knight},
            {".piece-cost-wB", Table.Game.WhitePieceCosts.Bishop},
            {".piece-cost-wR", Table.Game.WhitePieceCosts.Rook},
            {".piece-cost-wQ", Table.Game.WhitePieceCosts.Queen},
            {".mana-white", Table.Game.WhiteMana},

            {".piece-cost-bP", Table.Game.BlackPieceCosts.Pawn},
            {".piece-cost-bN", Table.Game.BlackPieceCosts.Knight},
            {".piece-cost-bB", Table.Game.BlackPieceCosts.Bishop},
            {".piece-cost-bR", Table.Game.BlackPieceCosts.Rook},
            {".piece-cost-bQ", Table.Game.BlackPieceCosts.Queen},
            {".mana-black", Table.Game.BlackMana}
        };
    }
    private string[] GetDebugStateString()
    {
        return new string[] {
            $"You are {Client.Id} ({Client.Player})",
            $"Opponent: {Client.GetOpponentClient()?.Id.ToString() ?? "none"}",
            Winner != Player.None ? $"{Winner} wins" : $"{Table.Game.WhoseTurn} to move",
            $"Allocated tables: {PiecemakerGame.AllocatedTables}",
            $"Open Tables: {PiecemakerGame.OpenTables}",
            $"Closed Tables: {PiecemakerGame.ClosedTables}",
            $"Ready Tables: {PiecemakerGame.ReadyTables}",
            $"Playing Tables: {PiecemakerGame.PlayingTables}",
            $"Paused Tables: {PiecemakerGame.PausedTables}",
            $"Finished Tables: {PiecemakerGame.FinishedTables}",
            $"Empty Tables: {PiecemakerGame.EmptyTables}"
        };
    }
    private async void Table_ClientJoined(object sender, Client e)
    {
        await InvokeAsync(StateHasChanged);
    }
    private async void Table_ClientDisconnected(object sender, Client e)
    {
        if (Client != e)
            await InvokeAsync(StateHasChanged);
    }
    private async void Table_SideSwapClicked(object sender, EventArgs e)
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("setOrientation", Client.Player.ToString().ToLower());
            await InvokeAsync(StateHasChanged);
        }
        catch (TaskCanceledException ex) { }
    }
    private async void Table_StatusChanged(object sender, Status e)
    {
        await InvokeAsync(StateHasChanged);
    }
    void IDisposable.Dispose()
    {
        Table.Disconnect(Client);
        System.Diagnostics.Debug.WriteLine($"{Client.Id} disconnected.");
    }
}
