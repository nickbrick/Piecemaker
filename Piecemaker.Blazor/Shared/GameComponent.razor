@implements IDisposable
@inject IJSRuntime JsRuntime
@using ChessDotCore.Pieces;
@using ChessDotCore;
<h3>Table @Table.Id.ToString("x")</h3>
<div id="myBoard" style="width: 400px"></div>
<audio id="audio-check" style="display:none;" src="/webm/move-check.webm"></audio>
<audio id="audio-capture" style="display:none;" src="/webm/capture.webm"></audio>
<audio id="audio-promote" style="display:none;" src="/webm/promote.webm"></audio>
<audio id="audio-move-opponent" style="display:none;" src="/webm/move-opponent.webm"></audio>
<audio id="audio-move-self" style="display:none;" src="/webm/move-self.webm"></audio>
<ul>
    @foreach (var line in Status)
    {
        <li>@line</li>
    }

</ul>
<p>Piecemaker alpha @System.Environment.GetEnvironmentVariable("HEROKU_RELEASE_VERSION")</p>
@code {
    public Client Client { get; set; }
    [Parameter]
    public Table Table { get; set; }
    private string[] Status => GetStatusString();
    private string SimpleFen => Table.Game.GetFen().Split()[0];
    private string LastMove => Table.Game.Moves.LastOrDefault()?.ToString() ?? "";
    private Player Winner => Table.Game.IsCheckmated(Player.White) ? Player.Black : Table.Game.IsCheckmated(Player.Black) ? Player.White : Player.None;
    [Inject]
    public IJSRuntime JSRuntime { get; set; }
    public GameComponent()
    {
    }
    protected async override void OnInitialized()
    {
        Table.ValidMoveWasMade += Table_ValidMoveWasMade;
        Table.ClientJoined += Table_ClientJoined;
        Table.ClientDisconnected += Table_ClientDisconnected;
        Client = Table.Join();
    }
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("init", Table.Game.GetFen(), Client.Player.ToString().ToLower()[0], LastMove);
            await InitGameComponentInstance();
        }
        await JSRuntime.InvokeVoidAsync("setValidMoves",
            Client.ValidMoves,
            Table.Game.WhoseTurn.ToString().ToLower()[0],
            Table.Game.WhiteSummonablePieces.Select(s => "w" + s).ToList().Concat(
            Table.Game.BlackSummonablePieces.Select(s => "b" + s.ToUpper()).ToList())
        );
        await JSRuntime.InvokeVoidAsync("updateMana", GetGameManasAndCosts());

    }
    private async Task InitGameComponentInstance()
    {
        var dotNetObjRef = DotNetObjectReference.Create(this);
        await JSRuntime.InvokeVoidAsync("registerGameComponentObject", dotNetObjRef);
    }
    [JSInvokable("MakeMove")]
    public async Task<bool> MakeMove(string move)
    {
        var result = Client.MakeMove(move);
        if (!result)
        {
            await JSRuntime.InvokeVoidAsync("setPosition", SimpleFen);
        }
        await InvokeAsync(StateHasChanged);
        return result;
    }
    private async void Table_ValidMoveWasMade(object sender, MoveEventArgs e)
    {
        System.Diagnostics.Debug.WriteLine(e.NewPositionSimpleFen);
        await JSRuntime.InvokeVoidAsync("setPosition", e.NewPositionSimpleFen);
        await JSRuntime.InvokeVoidAsync("highlightSquares", e.From, e.To);
        await JSRuntime.InvokeVoidAsync("playSound", GetSoundName(e));

        System.Diagnostics.Debug.WriteLine("Table_MoveWasMade");
        await InvokeAsync(StateHasChanged);
    }
    private string GetSoundName(MoveEventArgs e)
    {
        if (e.Type.HasFlag(MoveType.Check)) return "#audio-check";
        if (e.Type.HasFlag(MoveType.Capture)) return "#audio-capture";
        if (e.Type.HasFlag(MoveType.Summon)) return "#audio-promote";
        if (e.Player != Client.Player) return "#audio-move-opponent";
        return "#audio-move-self";
    }
    private Dictionary<string, int> GetGameManasAndCosts()
    {
        return new Dictionary<string, int>
    {
            {".piece-cost-wP", Table.Game.WhitePieceCosts.Pawn},
            {".piece-cost-wN", Table.Game.WhitePieceCosts.Knight},
            {".piece-cost-wB", Table.Game.WhitePieceCosts.Bishop},
            {".piece-cost-wR", Table.Game.WhitePieceCosts.Rook},
            {".piece-cost-wQ", Table.Game.WhitePieceCosts.Queen},
            {".mana-white", Table.Game.WhiteMana},

            {".piece-cost-bP", Table.Game.BlackPieceCosts.Pawn},
            {".piece-cost-bN", Table.Game.BlackPieceCosts.Knight},
            {".piece-cost-bB", Table.Game.BlackPieceCosts.Bishop},
            {".piece-cost-bR", Table.Game.BlackPieceCosts.Rook},
            {".piece-cost-bQ", Table.Game.BlackPieceCosts.Queen},
            {".mana-black", Table.Game.BlackMana}
        };
    }
    private async void Table_ClientJoined(object sender, Client e)
    {
        await InvokeAsync(StateHasChanged);
    }
    private async void Table_ClientDisconnected(object sender, Client e)
    {
        if (Client != e)
            await InvokeAsync(StateHasChanged);
    }
    private string[] GetStatusString()
    {
        return new string[] {
            $"You are {Client.Id} ({Client.Player})",
            $"Opponent: {Client.GetOpponentClient()?.Id.ToString() ?? "none"}",
            Winner != Player.None ? $"{Winner} wins" : $"{Table.Game.WhoseTurn} to move",
            $"♔: {Table.Game.GetMana(Player.White)} | ♕: {Table.Game.GetCost<Queen>(Player.White)} | ♖: {Table.Game.GetCost<Rook>(Player.White)} | ♗: {Table.Game.GetCost<Bishop>(Player.White)} | ♘: {Table.Game.GetCost<Knight>(Player.White)} | ♙: {Table.Game.GetCost<Pawn>(Player.White)}",
            $"♚: {Table.Game.GetMana(Player.Black)} | ♛: {Table.Game.GetCost<Queen>(Player.Black)} | ♜: {Table.Game.GetCost<Rook>(Player.Black)} | ♝: {Table.Game.GetCost<Bishop>(Player.Black)} | ♞: {Table.Game.GetCost<Knight>(Player.Black)} | ♟: {Table.Game.GetCost<Pawn>(Player.Black)}"
        };
    }
    void IDisposable.Dispose()
    {
        Table.Disconnect(Client);
        System.Diagnostics.Debug.WriteLine($"{Client.Id} disconnected.");
    }
}
